name: Check File Action
description: 'Check file - Add filename to check for errors or text Word to search for within workspace files'
inputs:
  filename:
    description: 'Check for filename or search for text word matches'
    type: string
    required: true
    default: ''
  filetype:
    description: 'Check only these file extension types when searching for text word matches'
    type: string
    required: false
    default: 'none'
  dirname:
    description: 'Your project root folder if created'
    type: string
    required: false
    default: ''
  rootdir:
    description: 'Search will start from root (/) if true'
    type: boolean
    required: false
    default: 'false'
  content:
    description: 'Search will list dir contents of found filename if true'
    type: boolean
    required: false
    default: 'false'
  include:
    description: 'Check include files called by C/C++ filename searches if true'
    type: boolean
    required: false
    default: 'false'

runs:
  using: composite
  steps:
    - name: Set up Go 1.25.3
      uses: actions/setup-go@v2 
      with: 
        go-version: 1.25.3

    - name: Installing Dependencies
      if: inputs.filename != ''
      run: |
        set -o allexport
        file_type=$(/usr/bin/echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        file=$(find ${GITHUB_WORKSPACE} -type f -name "checkmake.ini" -print -quit);
        path='/home/runner/checkmake.ini';
        if [[ ! `which checkmake` ]] && [[ ${file_type} = 'Makefile' ]] || [[ ${file_type} = 'makefile' ]] || [[ ${file_type} = 'mk' ]]; then
          go install "github.com/checkmake/checkmake/cmd/checkmake@latest" >/dev/null && /usr/bin/echo -e "\n####################\n\tCheckmake dependencies Installed\n####################\n";     
          if [[ -n ${file} ]]; then
            /usr/bin/echo -e "\n####################\n\tCheckmake.ini found\n\tcopying....\n####################\n";
            sudo cp -vf "${file}" "${path}" 2>/dev/null;
          fi;
        elif [[ -n ${file} ]] && [[ ${file_type} = 'Makefile' ]] || [[ ${file_type} = 'makefile' ]] || [[ ${file_type} = 'mk' ]]; then
          sudo cp -vf "${file}" "${path}" 2>/dev/null;
        fi;

        if [[ ! `which cppcheck` ]] && [[ ${file_type} = 'c' ]] || [[ ${file_type} = 'cc' ]] || [[ ${file_type} = 'cpp' ]] || [[ ${file_type} = 'cxx' ]] || [[ ${file_type} = 'h' ]] || [[ ${file_type} = 'hh' ]] || [[ ${file_type} = 'hpp' ]] || [[ ${file_type} = 'hxx' ]]; then
          sudo DEBIAN_FRONTEND=noninteractive apt-get -yq install cppcheck >/dev/null && /usr/bin/echo -e "\n####################\n\tCppcheck dependencies Installed\n####################\n";
        fi;

        if [[ ! `which shellcheck` ]] && [[ ${file_type} = 'sh' ]] || [[ ${file_type} = 'SH' ]]; then
          sudo DEBIAN_FRONTEND=noninteractive apt-get -yq install shellcheck >/dev/null && /usr/bin/echo -e "\n####################\n\tShellcheck dependencies Installed\n####################\n";
        fi;

        if [[ `which bat` ]] && [[ ! `which batcat` ]]; then
          sudo ln -sf ~/usr/bin/bat ~/usr/bin/batcat >/dev/null 2>&1;
          /usr/bin/echo "########## `which batcat` ##########" || /usr/bin/echo "No batcat found Exiting... `exit 0`";
          sudo bash -c /usr/bin/echo -e "\nalias bat='batcat'" >> ~/.bashrc 2>/dev/null;
        elif [[ ! `which batcat` ]]; then
          sudo DEBIAN_FRONTEND=noninteractive apt-get -yq install bat >/dev/null && /usr/bin/echo -e "\n####################\n\tbatcat dependencies Installed\n####################\n";
          /usr/bin/echo "########## `which batcat` ##########" || /usr/bin/echo "No batcat found Exiting... `exit 0`";
        fi;
      shell: bash
      continue-on-error: false

    - name: Directory Base
      if: inputs.filename != ''
      run: |
        /usr/bin/echo ''
        if ${{ inputs.rootdir }}; then
          /usr/bin/echo -e "\n####################\nNOTE: Search default directory ( ~/ )\n####################\n";
          /usr/bin/echo "FILE_PATH=/" >> "${GITHUB_ENV}";
          /usr/bin/echo "FILE_FOUND=0" >> "${GITHUB_ENV}";
        else
          /usr/bin/echo -e "\n####################\nNOTE: Search default directory ( ${GITHUB_WORKSPACE} )\n####################\n";
          /usr/bin/echo "FILE_PATH=${GITHUB_WORKSPACE}" >> "${GITHUB_ENV}";
          /usr/bin/echo "FILE_FOUND=0" >> "${GITHUB_ENV}";
        fi;
      shell: bash
      continue-on-error: false

    - name: Check File (user mode)
      if: inputs.rootdir != 'true' && inputs.filename != ''
      run: |
        /usr/bin/echo ''
        /usr/bin/echo -e "\n####################\nSearching from github workspace directory for ${{ inputs.filename }} matches.\n####################\n";
        export GIT_DISCOVERY_ACROSS_FILESYSTEM=1
        files=$(find ${{ env.FILE_PATH }} -type f \( -path "*/${{ inputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}" -print);
        file_type=$(/usr/bin/echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        file_count=1
        include_count=1
        makefile_count=1
        shellcheck_count=1
        if [[ $(/usr/bin/echo "${file_type}" | egrep "c*|h*|t*") ]] && [[ -n ${files} ]]; then
          /usr/bin/echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          /usr/bin/echo -e "\nFound File Path(s):\n${files}\n";
          for f in ${files[@]}; do
            count1=$((file_count++));
            /usr/bin/echo -e "\n####################\n\tFILE PATH ($count1)\n####################\n";
            /usr/bin/echo $(dirname $(find $(dirname ${f}) -type f -name $(basename ${f}) -print));
            if ${{ inputs.content }}; then
              /usr/bin/echo -e "\n####################\n\tFILE CONTENT ($count1)\n####################\n";
              find $(dirname ${f}) -type f -name $(basename ${f}) -exec batcat --paging=never --theme=GitHub --theme-dark --theme-light --show-all --color=always --style=full "{}" \;
            fi;
              /usr/bin/echo -e "\n\n####################\nCPPCHECK ERROR ANALYZER ($count1)\n####################\n\n";
              cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" "${f}";
            if ${{ inputs.include }}; then
              includes=$(find $(dirname ${f}) -name $(basename ${f}) -exec sed -n 's/^#include <\(.*\)>/\1/p; s/^#include "\(.*\)"/\1/p' "{}" \;);
              included1='include_file.txt'
              included2='include_paths.txt'
              if [[ -f $(dirname ${f})/${included2} ]]; then
                rm -vf "$(dirname ${f})/${included1}" "$(dirname ${f})/${included2}" 2>/dev/null;
              fi;
              if [[ -n ${includes} ]]; then
                /usr/bin/echo -e "\nFound Include Path(s):\n${includes}\n";
                for i in ${includes[@]}; do
                  count2=$((include_count++));
                  header=$(find $(/usr/bin/echo $(dirname ${f}) | cut -d/ -f1-8) -type f \( -path "*/$(dirname ${i})/*" -o -path "*" \) -name "$(basename ${i})" -print -quit) 2>/dev/null;
                  for h in "${header[@]}"; do
                    /usr/bin/echo "$(dirname ${h})" >> "$(dirname ${f})/${included1}";
                  done
                done;
                awk '!seen[$0]++' "$(dirname ${f})/${included1}" > "$(dirname ${f})/${included2}";
                if [[ -f ${header} ]] && [[ -f $(dirname ${f})/${included2} ]]; then
                  included3=$(dirname ${f})/${included2}
                  batcat --paging=never --theme=GitHub --theme-dark --theme-light --show-all --color=always --style=full  ${included3};
                  /usr/bin/echo -e "\n\n####################\nCPPCHECK INCLUDED HEADER FILES ($count2)\n####################\n\nFinal File: ${i}\n\n";
                  cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" --includes-file="${included3}" "${f}";
                else
                  /usr/bin/echo -e "\n\n####################\nCPPCHECK INCLUDED HEADER(S) FOR $(basename ${f}) NOT FOUND\n####################\n\n";
                fi;
              fi;
            fi;
          done;
          if [[ -f $(dirname ${f})/${included2} ]]; then
            /usr/bin/echo '';
            rm -vf "$(dirname ${f})/${included1}" "$(dirname ${f})/${included2}" 2>/dev/null;
          fi;
          /usr/bin/echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: $count1\n";
          /usr/bin/echo -e "Total number of included file(s) checked is: $count2\n";
          /usr/bin/echo -e "Scanning Completed!\nCppcheck Exiting!\n .....\n";
        elif [[ $(/usr/bin/echo "${file_type}" | grep -i "sh") ]] && [[ -n ${files} ]]; then
          /usr/bin/echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          for f in ${files[@]}; do
            count3=$((shellcheck_count++));
            /usr/bin/echo -e "\n\n####################\nSHELLCHECK ANALYZING $(basename ${s}) FOR ERROR(S) ($count3)\n####################\n\n";
            shellcheck --norc --severity=error "${f}" || /usr/bin/echo -e "\n####################\nSHELLCHECK FOUND ERROR(S)\n####################\n";
            [ $? -eq 0 ] && /usr/bin/echo -e "\n####################\nSHELLCHECK NO ERRORS FOUND ( ${f} )\n####################\n"
            if ${{ inputs.content }}; then
              /usr/bin/echo -e "\n####################\n\tFILE CONTENT ($count3)\n####################\n\n";
              batcat --paging=never --theme=GitHub --theme-dark --theme-light --show-all --color=always --style=full "${f}";
              /usr/bin/echo -e "\n\n";
            fi;
          done;
          /usr/bin/echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: $count3\n";
          /usr/bin/echo -e "Scanning Completed!\nShellcheck Exiting!\n .....\n";
        elif [[ $(/usr/bin/echo "${file_type}" | egrep -i "mk|.*Makefile|Makefile") ]] && [[ -n ${files} ]]; then
          /usr/bin/echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          for f in ${files[@]}; do
            count4=$((makefile_count++));
            /usr/bin/echo -e "\n####################\nCHECKMAKE ANALYZING $(basename ${f}) FOR ERROR(S) ($count4)\n####################\n";
            checkmake "${f}" || /usr/bin/echo -e "\n####################\nCHECKMAKE FOUND ERROR(S)\n####################\n";
            [ $? -eq 0 ] && /usr/bin/echo -e "\n####################\nCHECKMAKE NO ERRORS FOUND $(dirname ${f})\n####################\n"
            if ${{ inputs.content }}; then
              /usr/bin/echo -e "\n####################\n\tFILE CONTENT\n####################\n\n";
              batcat --paging=never --theme=GitHub --theme-dark --theme-light --show-all --color=always --style=full "${f}";
              /usr/bin/echo -e "\n\n";
            fi;
          done;
          /usr/bin/echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: $count4\n";
          /usr/bin/echo -e "Scanning Completed!\nCheckMake Exiting!\n .....\n";
        elif [[ -n ${files} ]]; then
            /usr/bin/echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
            for f in ${files[@]}; do
              count5=$((file_count++));
              /usr/bin/echo -e "\n####################\n\tFILE PATH ($count5)\n####################\n";
              /usr/bin/echo "$(dirname $(find $(dirname ${f}) -type f -name $(basename ${f}) -print))";
              if ${{ inputs.content }}; then
                /usr/bin/echo -e "\n####################\n\tFILE CONTENT ($count5)\n####################\n\n";
                batcat --paging=never --theme=GitHub --theme-dark --theme-light --show-all --color=always --style=full "${f}";
                /usr/bin/echo -e "\n\n";
              fi;
            done;
          /usr/bin/echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: $count5\n";
          /usr/bin/echo -e "Scanning Completed!\nCheckfile Exiting!\n .....\n";
        else
          /usr/bin/echo -e "\n####################\nFINISHED SEARCHING ${{ inputs.filename }} NOT FOUND \n####################\n";
        fi;
      shell: bash
      continue-on-error: true

    - name: Text (String) Match
      if: inputs.rootdir != 'true' && inputs.filename != ''
      run: |
        /usr/bin/echo ''
        file_count=1
        file_type=$(/usr/bin/echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');  
        if [[ ${{ env.FILE_FOUND }} == 0  ]] && [[ ${{ inputs.filetype }} != 'none' ]] && [[ ${file_type} == ${{ inputs.filename }} ]]; then
          for t in ${{ inputs.filetype }}; do
            finder=$(find ${{ env.FILE_PATH }} -type f \( -path "*/${{ inputs.dirname }}/*" -o -path "*" \) -name "*${t}" -exec grep --color=always -Hans "${{ inputs.filename }}" "{}" \; -printf "%p\n");
            content=$(find ${{ env.FILE_PATH }} -type f \( -path "*/${{ inputs.dirname }}/*" -o -path "*" \) -name "*${t}" -exec grep --color=always -q "${{ inputs.filename }}" "{}" \; -printf "%p\n");
            if [[ -n ${finder} ]]; then
              counter=$( /usr/bin/echo "${finder}" | grep -c "${{ inputs.filename }}" );
              /usr/bin/echo -e "\n####################\n ($counter) CONTENT MATCH(S) FOUND IN ${{ inputs.filetype }} FILE(S) \n####################\n";
              /usr/bin/echo -e "\n${finder}\n";
              if ${{ inputs.content }}; then
                for c in ${content[@]}; do
                  count=$((file_count++));
                  /usr/bin/echo -e "\n####################\nFILE PATH:\n$(dirname ${c})\n####################\n";
                  /usr/bin/echo -e "\n####################\n\tFILE CONTENT ($count)\n####################\n\n";
                  batcat --paging=never --theme=GitHub --theme-dark --theme-light --show-all --color=always --style=full "${c}";
                  /usr/bin/echo -e "\n####################\nFILE COMPLETED\n####################\n";
                done;
              fi;
            else
              /usr/bin/echo -e "\n####################\nFINISHED SEARCHING ALL FILES\n####################\n";
          fi;
          done;
          /usr/bin/echo -e "\nScanning Completed!\nText Locator\nExiting!\t .....\n"
        elif [[ ${{ env.FILE_FOUND }} == 0  ]] && [[ ${file_type} == ${{ inputs.filename }} ]]; then
          finder=$(find ${{ env.FILE_PATH }} -type f \( -path "*/${{ inputs.dirname }}/*" -o -path "*" \) -name "*" -exec grep --color=always -Hans "${{ inputs.filename }}" "{}" \; -printf "%p\n");
          content=$(find ${{ env.FILE_PATH }} -type f \( -path "*/${{ inputs.dirname }}/*" -o -path "*" \) -name "*" -exec grep --color=always -q "${{ inputs.filename }}" "{}" \; -printf "%p\n");
          if [[ -n ${finder} ]]; then
              counter=$( /usr/bin/echo "${finder}" | grep -c "${{ inputs.filename }}" );
              /usr/bin/echo -e "\n####################\n ($counter) CONTENT MATCH(S) FOUND IN FILE(S) \n####################\n";
              /usr/bin/echo -e "\n${finder}\n";
              if ${{ inputs.content }}; then
                for c in ${content[@]}; do
                  count=$((file_count++));
                  /usr/bin/echo -e "\n####################\nFILE PATH:\n$(dirname ${c})\n####################\n";
                  /usr/bin/echo -e "\n####################\n\tFILE CONTENT ($count)\n####################\n\n";
                  batcat --paging=never --theme=GitHub --theme-dark --theme-light --show-all --color=always --style=full "${c}";
                  /usr/bin/echo -e "\n####################\nFILE COMPLETED\n####################\n";
                done;
              fi;
            else
              /usr/bin/echo -e "\n####################\nFINISHED SEARCHING ALL FILES\n####################\n";
          fi;
          /usr/bin/echo -e "\nScanning Completed!\nText Locator\nExiting!\t .....\n"
        fi;
      shell: bash
      continue-on-error: true

    - name: Check File (root mode)
      if: inputs.rootdir == 'true' && inputs.filename != ''
      run: |
        /usr/bin/echo ''
        /usr/bin/echo -e "\n####################\nSearching from github workspace directory for ${{ inputs.filename }} matches.\n####################\n";
        export GIT_DISCOVERY_ACROSS_FILESYSTEM=1
        files=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ inputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}" -print);
        file_type=$(/usr/bin/echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        file_count=1
        include_count=1
        makefile_count=1
        shellcheck_count=1
        if [[ $(/usr/bin/echo "${file_type}" | egrep "c*|h*|t*") ]] && [[ -n ${files} ]]; then
          /usr/bin/echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          /usr/bin/echo -e "\nFound File Path(s):\n${files}\n";
          for f in ${files[@]}; do
            count1=$((file_count++));
            /usr/bin/echo -e "\n####################\n\tFILE PATH ($count1)\n####################\n";
            /usr/bin/echo $(dirname $(sudo find $(dirname ${f}) -type f -name $(basename ${f}) -print));
            if ${{ inputs.content }}; then
              /usr/bin/echo -e "\n####################\n\tFILE CONTENT ($count1)\n####################\n";
              sudo find $(dirname ${f}) -type f -name $(basename ${f}) -exec batcat --paging=never --theme=GitHub --theme-dark --theme-light --show-all --color=always --style=full "{}" \;
            fi;
              /usr/bin/echo -e "\n\n####################\nCPPCHECK ERROR ANALYZER ($count1)\n####################\n\n";
              cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" "${f}";
            if ${{ inputs.include }}; then
              includes=$(sudo find $(dirname ${f}) -name $(basename ${f}) -exec sed -n 's/^#include <\(.*\)>/\1/p; s/^#include "\(.*\)"/\1/p' "{}" \;);
              included1='include_file.txt'
              included2='include_paths.txt'
              if [[ -f $(dirname ${f})/${included2} ]]; then
                rm -vf "$(dirname ${f})/${included1}" "$(dirname ${f})/${included2}" 2>/dev/null;
              fi;
              if [[ -n ${includes} ]]; then
                /usr/bin/echo -e "\nFound Include Path(s):\n${includes}\n";
                for i in ${includes[@]}; do
                  count2=$((include_count++));
                  header=$(sudo find $(/usr/bin/echo $(dirname ${f}) | cut -d/ -f1-8) -type f \( -path "*/$(dirname ${i})/*" -o -path "*" \) -name "$(basename ${i})" -print -quit) 2>/dev/null;
                  for h in "${header[@]}"; do
                    /usr/bin/echo "$(dirname ${h})" >> "$(dirname ${f})/${included1}";
                  done
                done;
                awk '!seen[$0]++' "$(dirname ${f})/${included1}" > "$(dirname ${f})/${included2}";
                if [[ -f ${header} ]] && [[ -f $(dirname ${f})/${included2} ]]; then
                  included3=$(dirname ${f})/${included2}
                  batcat --paging=never --theme=GitHub --theme-dark --theme-light --show-all --color=always --style=full ${included3};
                  /usr/bin/echo -e "\n\n####################\nCPPCHECK INCLUDED HEADER FILES ($count2)\n####################\n\nFinal File: ${i}\n\n";
                  cppcheck --verbose --force --enable=all --std=c++11 --report-progress --suppress=checkersReport --suppress=missingInclude --suppress=missingIncludeSystem --suppress=unmatchedSuppression:"{}" --includes-file="${included3}" "${f}";
                else
                  /usr/bin/echo -e "\n\n####################\nCPPCHECK INCLUDED HEADER(S) FOR $(basename ${f}) NOT FOUND\n####################\n\n";
                fi;
              fi;
            fi;
          done;
          if [[ -f $(dirname ${f})/${included2} ]]; then
            /usr/bin/echo '';
            rm -vf "$(dirname ${f})/${included1}" "$(dirname ${f})/${included2}" 2>/dev/null;
          fi;
          /usr/bin/echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: $count1\n";
          /usr/bin/echo -e "Total number of included file(s) checked is: $count2\n";
          /usr/bin/echo -e "Scanning Completed!\nCppcheck Exiting!\n .....\n";
        elif [[ $(/usr/bin/echo "${file_type}" | grep -i "sh") ]] && [[ -n ${files} ]]; then
          /usr/bin/echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          for f in ${files[@]}; do
            count3=$((shellcheck_count++));
            /usr/bin/echo -e "\n\n####################\nSHELLCHECK ANALYZING $(basename ${s}) FOR ERROR(S) ($count3)\n####################\n\n";
            shellcheck --norc --severity=error "${f}" || /usr/bin/echo -e "\n####################\nSHELLCHECK FOUND ERROR(S)\n####################\n";
            [ $? -eq 0 ] && /usr/bin/echo -e "\n####################\nSHELLCHECK NO ERRORS FOUND $(basename ${f})\n####################\n"
            if ${{ inputs.content }}; then
              /usr/bin/echo -e "\n####################\n\tFILE CONTENT ($count3)\n####################\n\n";
              batcat --paging=never --theme=GitHub --theme-dark --theme-light --show-all --color=always --style=full "${f}";
              /usr/bin/echo -e "\n\n";
            fi;
          done;
          /usr/bin/echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: $count3\n";
          /usr/bin/echo -e "Scanning Completed!\nShellcheck Exiting!\n .....\n";
        elif [[ $(/usr/bin/echo "${file_type}" | egrep -i "mk|.*Makefile|Makefile") ]] && [[ -n ${files} ]]; then
          /usr/bin/echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          for f in ${files[@]}; do
            count4=$((makefile_count++));
            /usr/bin/echo -e "\n####################\nCHECKMAKE ANALYZING $(basename ${f}) FOR ERROR(S) ($count4)\n####################\n";
            checkmake "${f}" || /usr/bin/echo -e "\n####################\nCHECKMAKE FOUND ERROR(S)\n####################\n";
            [ $? -eq 0 ] && /usr/bin/echo -e "\n####################\nCHECKMAKE NO ERRORS FOUND $(basename ${f})\n####################\n";
            if ${{ inputs.content }}; then
              /usr/bin/echo -e "\n####################\n\tFILE CONTENT ($count4)\n####################\n\n";
              batcat --paging=never --theme=GitHub --theme-dark --theme-light --show-all --color=always --style=full "${f}";
              /usr/bin/echo -e "\n\n";
            fi;
          done;
          /usr/bin/echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: $count4\n";
          /usr/bin/echo -e "Scanning Completed!\nCheckMake Exiting!\n .....\n";
        elif [[ -n ${files} ]]; then
          /usr/bin/echo "FILE_FOUND=1" >> "${GITHUB_ENV}";
          for f in ${files[@]}; do
            count5=$((file_count++));
            /usr/bin/echo -e "\n####################\n\tFILE PATH ($count5)\n####################\n";
            /usr/bin/echo "$(dirname $(sudo find $(dirname ${f}) -type f -name $(basename ${f}) -print))";
            if ${{ inputs.content }}; then
              /usr/bin/echo -e "\n####################\n\tFILE CONTENT ($count5)\n####################\n\n";
              batcat --paging=never --theme=GitHub --theme-dark --theme-light --show-all --color=always --style=full "${f}";
              /usr/bin/echo -e "\n\n";
            fi;
          done;
          /usr/bin/echo -e "\nTotal number of ${{ inputs.filename }} file(s) checked is: $count5\n";
          /usr/bin/echo -e "Scanning Completed!\nCheckfile Exiting!\n .....\n";
        else
          /usr/bin/echo -e "\n####################\nFINISHED SEARCHING ${{ inputs.filename }} NOT FOUND \n####################\n";
        fi;
      shell: bash
      continue-on-error: true

    - name: Text (String) Match
      if: inputs.rootdir == 'true' && inputs.filename != ''
      run: |
        /usr/bin/echo ''
        file_count=1
        file_type=$(/usr/bin/echo ${{ inputs.filename }} | sed 's/.*\.\([^.]*\)$/\1/');
        if [[ ${{ env.FILE_FOUND }} == 0  ]] && [[ ${{ inputs.filetype }} != 'none' ]] && [[ ${file_type} == ${{ inputs.filename }} ]]; then
          for t in ${{ inputs.filetype }}; do
            finder=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ inputs.dirname }}/*" -o -path "*" \) -name "*${t}" -exec grep --color=always -Hans "${{ inputs.filename }}" "{}" \; -printf "%p\n");
            content=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ inputs.dirname }}/*" -o -path "*" \) -name "*${t}" -exec grep --color=always -q "${{ inputs.filename }}" "{}" \; -printf "%p\n");
            if [[ -n ${finder} ]]; then
              counter=$( /usr/bin/echo "${finder}" | grep -c "${{ inputs.filename }}" );
              /usr/bin/echo -e "\n####################\n ($counter) CONTENT MATCH(S) FOUND IN ${{ inputs.filetype }} FILE(S) \n####################\n";
              /usr/bin/echo -e "\n${finder}\n";
              if ${{ inputs.content }}; then
                for c in ${content[@]}; do
                  count=$((file_count++));
                  /usr/bin/echo -e "\n####################\nFILE PATH:\n$(dirname ${c})\n####################\n";
                  /usr/bin/echo -e "\n####################\n\tFILE CONTENT ($count)\n####################\n\n";
                  batcat --paging=never --theme=GitHub --theme-dark --theme-light --show-all --color=always --style=full "${c}";
                  /usr/bin/echo -e "\n####################\nFILE COMPLETED\n####################\n";
                done;
              fi;
            else
              /usr/bin/echo -e "\n####################\nFINISHED SEARCHING ALL FILES\n####################\n";
          fi;
          done;
          /usr/bin/echo -e "\nScanning Completed!\nText Locator\nExiting!\t .....\n"
        elif [[ ${{ env.FILE_FOUND }} == 0  ]]  && [[ ${file_type} == ${{ inputs.filename }} ]]; then
          finder=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ inputs.dirname }}/*" -o -path "*" \) -name "*" -exec grep --color=always -Hans "${{ inputs.filename }}" "{}" \; -printf "%p\n");
          content=$(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ inputs.dirname }}/*" -o -path "*" \) -name "*" -exec grep --color=always -q "${{ inputs.filename }}" "{}" \; -printf "%p\n");
          if [[ -n ${finder} ]]; then
              counter=$( /usr/bin/echo "${finder}" | grep -c "${{ inputs.filename }}" );
              /usr/bin/echo -e "\n####################\n ($counter) CONTENT MATCH(S) FOUND IN FILE(S) \n####################\n";     
              /usr/bin/echo -e "\n${finder}\n";
              if ${{ inputs.content }}; then
                for c in ${content[@]}; do
                  count=$((file_count++));
                  /usr/bin/echo -e "\n####################\nFILE PATH:\n$(dirname ${c})\n####################\n";
                  /usr/bin/echo -e "\n####################\n\tFILE CONTENT ($count)\n####################\n\n";
                  batcat --paging=never --theme=GitHub --theme-dark --theme-light --show-all --color=always --style=full "${c}";
                  /usr/bin/echo -e "\n####################\nFILE COMPLETED\n####################\n";
                done;
              fi;
            else
              /usr/bin/echo -e "\n####################\nFINISHED SEARCHING ALL FILES\n####################\n";
          fi;
          /usr/bin/echo -e "\nScanning Completed!\nText Locator\nExiting!\t .....\n"
        fi;
      shell: bash
      continue-on-error: true

    - name: Directory Contains
      if: inputs.filename != '' && inputs.content != false
      run: |
        set +e
        if [[ ${{ env.FILE_FOUND }} != 0  ]]; then
          if ${{ inputs.rootdir }}; then
            /usr/bin/echo -e "\n####################\nNOTE: Contents found in directory(s) for ${{ inputs.filename }}\n####################\n";
            ls -Shp $(dirname $(sudo find ${{ env.FILE_PATH }} -type f \( -path "*/${{ inputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}"));
            /usr/bin/echo -e "\n####################\nCHECK FILE EXITING ....\n####################";
          else
            /usr/bin/echo -e "\n####################\nNOTE: Contents found in directory(s) for ${{ inputs.filename }}\n####################\n";
            ls -Shp $(dirname $(find ${{ env.FILE_PATH }} -type f \( -path "*/${{ inputs.dirname }}/*" -o -path "*" \) -name "${{ inputs.filename }}"));
            /usr/bin/echo -e "\n####################\nCHECK FILE EXITING ....\n####################";
          fi;
        fi;
      shell: bash
      continue-on-error: true

    - name: Filename Check
      if: inputs.filename == ''
      run: |
        /usr/bin/echo ''
        /usr/bin/echo -e "\nNo input provided!\nVariable not set • filename\n\t.... Exiting\n';
      shell: bash
      continue-on-error: false
